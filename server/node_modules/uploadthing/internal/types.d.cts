import * as S from '@effect/schema/Schema';
import { Schema } from '@effect/schema/Schema';
import * as LogLevel from 'effect/LogLevel';
import { Json, MaybePromise, ErrorMessage, FileRouterInputConfig, RouteOptions, UploadThingError, FetchEsque, Simplify } from '@uploadthing/shared';

/**
 * TODO: Do we wanna support effect/schema parsers now??
 */
type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;
type ParserZodEsque<TInput, TParsedInput extends Json> = {
    _input: TInput;
    _output: TParsedInput;
    parse: ParseFn<TParsedInput>;
};
type JsonParser = ParserZodEsque<Json, Json>;

declare const FileUploadData_base: S.Class<FileUploadData, {
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
    lastModified: S.optional<typeof S.Number>;
}, S.Struct.Encoded<{
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
    lastModified: S.optional<typeof S.Number>;
}>, never, {
    readonly name: string;
} & {
    readonly size: number;
} & {
    readonly type: string;
} & {
    readonly lastModified?: number | undefined;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */
/**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */
declare class FileUploadData extends FileUploadData_base {
}
declare const FileUploadDataWithCustomId_base: S.Class<FileUploadDataWithCustomId, {
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
    lastModified: S.optional<typeof S.Number>;
} & {
    customId: S.NullOr<typeof S.String>;
}, {
    readonly name: string;
    readonly size: number;
    readonly type: string;
} & {
    readonly lastModified?: number | undefined;
} & {
    readonly customId: string | null;
} & {}, never, {
    readonly name: string;
} & {
    readonly size: number;
} & {
    readonly type: string;
} & {
    readonly lastModified?: number | undefined;
} & {
    readonly customId: string | null;
}, FileUploadData, {}>;
/**
 * `.middleware()` can add a customId to the incoming file data
 */
declare class FileUploadDataWithCustomId extends FileUploadDataWithCustomId_base {
}
declare const UploadedFileData_base: S.Class<UploadedFileData, {
    name: typeof S.String;
    size: typeof S.Number;
    type: typeof S.String;
    lastModified: S.optional<typeof S.Number>;
} & {
    customId: S.NullOr<typeof S.String>;
} & {
    key: typeof S.String;
    url: typeof S.String;
    appUrl: typeof S.String;
}, {
    readonly name: string;
    readonly size: number;
    readonly type: string;
} & {
    readonly lastModified?: number | undefined;
} & {
    readonly customId: string | null;
} & {} & {
    readonly key: string;
    readonly url: string;
    readonly appUrl: string;
} & {}, never, {
    readonly name: string;
} & {
    readonly size: number;
} & {
    readonly type: string;
} & {
    readonly lastModified?: number | undefined;
} & {
    readonly customId: string | null;
} & {
    readonly key: string;
} & {
    readonly url: string;
} & {
    readonly appUrl: string;
}, FileUploadDataWithCustomId, {}>;
/**
 * When files are uploaded, we get back
 * - a key
 * - a direct URL for the file
 * - an app-specific URL for the file (useful for scoping eg. for optimization allowed origins)
 */
declare class UploadedFileData extends UploadedFileData_base {
}
declare const NewPresignedUrl_base: S.Class<NewPresignedUrl, {
    url: typeof S.String;
    key: typeof S.String;
    customId: S.NullOr<typeof S.String>;
    name: typeof S.String;
}, S.Struct.Encoded<{
    url: typeof S.String;
    key: typeof S.String;
    customId: S.NullOr<typeof S.String>;
    name: typeof S.String;
}>, never, {
    readonly name: string;
} & {
    readonly customId: string | null;
} & {
    readonly key: string;
} & {
    readonly url: string;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */
declare class NewPresignedUrl extends NewPresignedUrl_base {
}
declare const UploadActionPayload_base: S.Class<UploadActionPayload, {
    files: S.Array$<typeof FileUploadData>;
    input: S.Schema<Json>;
}, S.Struct.Encoded<{
    files: S.Array$<typeof FileUploadData>;
    input: S.Schema<Json>;
}>, never, {
    readonly files: readonly FileUploadData[];
} & {
    readonly input: Json;
}, {}, {}>;
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */
declare class UploadActionPayload extends UploadActionPayload_base {
}

/**
 * Marker used to append a `customId` to the incoming file data in `.middleware()`
 * @example
 * ```ts
 * .middleware((opts) => {
 *   return {
 *     [UTFiles]: opts.files.map((file) => ({
 *       ...file,
 *       customId: generateId(),
 *     }))
 *   };
 * })
 * ```
 */
declare const UTFiles: unique symbol;
declare const unsetMarker: "unsetMarker" & {
    __brand: "unsetMarker";
};
type UnsetMarker = typeof unsetMarker;
type ValidMiddlewareObject = {
    [UTFiles]?: Partial<FileUploadDataWithCustomId>[];
    [key: string]: unknown;
};
type ResolverOptions<TParams extends AnyParams> = {
    metadata: Simplify<TParams["_metadata"] extends UnsetMarker ? undefined : Omit<TParams["_metadata"], typeof UTFiles>>;
    file: UploadedFileData;
};
/**
 * Different frameworks have different request and response types
 */
type MiddlewareFnArgs<TRequest, TResponse, TEvent> = {
    req: TRequest;
    res: TResponse;
    event: TEvent;
};
interface AnyParams {
    _routeOptions: any;
    _input: any;
    _metadata: any;
    _middlewareArgs: MiddlewareFnArgs<any, any, any>;
    _errorShape: any;
    _errorFn: any;
    _output: any;
}
type MiddlewareFn<TInput extends Json | UnsetMarker, TOutput extends ValidMiddlewareObject, TArgs extends MiddlewareFnArgs<any, any, any>> = (opts: TArgs & {
    files: Schema.Type<typeof UploadActionPayload>["files"];
    input: TInput extends UnsetMarker ? undefined : TInput;
}) => MaybePromise<TOutput>;
type ResolverFn<TOutput extends Json | void, TParams extends AnyParams> = (opts: ResolverOptions<TParams>) => MaybePromise<TOutput>;
type UploadErrorFn = (input: {
    error: UploadThingError;
    fileKey: string;
}) => Promise<void> | void;
interface UploadBuilder<TParams extends AnyParams> {
    input: <TParser extends JsonParser>(parser: TParams["_input"] extends UnsetMarker ? TParser : ErrorMessage<"input is already set">) => UploadBuilder<{
        _routeOptions: TParams["_routeOptions"];
        _input: TParser["_output"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    middleware: <TOutput extends ValidMiddlewareObject>(fn: TParams["_metadata"] extends UnsetMarker ? MiddlewareFn<TParams["_input"], TOutput, TParams["_middlewareArgs"]> : ErrorMessage<"middleware is already set">) => UploadBuilder<{
        _routeOptions: TParams["_routeOptions"];
        _input: TParams["_input"];
        _metadata: TOutput;
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: UnsetMarker;
    }>;
    onUploadComplete: <TOutput extends Json | void>(fn: ResolverFn<TOutput, TParams>) => Uploader<{
        _routeOptions: TParams["_routeOptions"];
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: TParams["_errorFn"];
        _output: TOutput;
    }>;
    onUploadError: (fn: TParams["_errorFn"] extends UnsetMarker ? UploadErrorFn : ErrorMessage<"onUploadError is already set">) => UploadBuilder<{
        _routeOptions: TParams["_routeOptions"];
        _input: TParams["_input"];
        _metadata: TParams["_metadata"];
        _middlewareArgs: TParams["_middlewareArgs"];
        _errorShape: TParams["_errorShape"];
        _errorFn: UploadErrorFn;
        _output: UnsetMarker;
    }>;
}
type UploadBuilderDef<TParams extends AnyParams> = {
    routerConfig: FileRouterInputConfig;
    routeOptions: RouteOptions;
    inputParser: JsonParser;
    middleware: MiddlewareFn<TParams["_input"], {}, TParams["_middlewareArgs"]>;
    errorFormatter: (err: UploadThingError) => TParams["_errorShape"];
    onUploadError: UploadErrorFn;
};
interface Uploader<TParams extends AnyParams> {
    _def: TParams & UploadBuilderDef<TParams>;
    resolver: ResolverFn<TParams["_output"], TParams>;
}
type AnyUploader = Uploader<AnyParams>;
type FileRouter<TParams extends AnyParams = AnyParams> = Record<string, Uploader<TParams>>;
type RouteHandlerConfig = {
    logLevel?: LogLevel.Literal;
    callbackUrl?: string;
    token?: string;
    /**
     * Used to determine whether to run dev hook or not
     * @default `env.NODE_ENV === "development" || env.NODE_ENV === "dev"`
     */
    isDev?: boolean;
    /**
     * Used to override the fetch implementation
     * @default `globalThis.fetch`
     */
    fetch?: FetchEsque;
    /**
     * Set how UploadThing should handle the daemon promise before returning a response to the client.
     * You can also provide a synchronous function that will be called before returning a response to
     * the client. This can be useful for things like:
     * -  [`@vercel/functions.waitUntil`](https://vercel.com/docs/functions/functions-api-reference#waituntil)
     * - [`next/after`](https://nextjs.org/blog/next-15-rc#executing-code-after-a-response-with-nextafter-experimental)
     * - or equivalent function from your serverless infrastructure provider that allows asynchronous streaming
     * If deployed on a stateful server, you most likely want "void" to run the daemon in the background.
     * @remarks - `"await"` is not allowed in development environments
     * @default isDev === true ? "void" : "await"
     */
    handleDaemonPromise?: "void" | "await" | ((promise: Promise<unknown>) => void);
    /**
     * URL override for the ingest server
     */
    ingestUrl?: string;
};
type RouteHandlerOptions<TRouter extends FileRouter> = {
    router: TRouter;
    config?: RouteHandlerConfig;
};
type inferEndpointInput<TUploader extends Uploader<any>> = TUploader["_def"]["_input"] extends UnsetMarker ? undefined : TUploader["_def"]["_input"];
type inferEndpointOutput<TUploader extends AnyUploader> = TUploader["_def"]["_output"] extends UnsetMarker | void | undefined ? null : TUploader["_def"]["_routeOptions"]["awaitServerData"] extends false ? null : TUploader["_def"]["_output"];
type inferErrorShape<TRouter extends FileRouter> = TRouter[keyof TRouter]["_def"]["_errorShape"];
/**
 * Map actionType to the required payload for that action
 * @todo Look into using @effect/rpc :thinking:
 */
type UTEvents = {
    upload: {
        in: typeof UploadActionPayload.Type;
        out: ReadonlyArray<NewPresignedUrl>;
    };
};

export { type AnyParams, type AnyUploader, type FileRouter, type MiddlewareFnArgs, type RouteHandlerConfig, type RouteHandlerOptions, type UTEvents, UTFiles, type UnsetMarker, type UploadBuilder, type UploadBuilderDef, type Uploader, type ValidMiddlewareObject, type inferEndpointInput, type inferEndpointOutput, type inferErrorShape };
