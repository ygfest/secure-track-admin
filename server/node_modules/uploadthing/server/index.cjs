Object.defineProperty(exports, '__esModule', { value: true });

var Effect = require('effect/Effect');
var shared = require('@uploadthing/shared');
var platform = require('@effect/platform');
var S = require('@effect/schema/Schema');
var effectLog = require('effect-log');
var Config = require('effect/Config');
var Context = require('effect/Context');
var Layer = require('effect/Layer');
var ManagedRuntime = require('effect/ManagedRuntime');
var Match = require('effect/Match');
var ConfigProvider = require('effect/ConfigProvider');
var Stream = require('effect/Stream');
var Logger = require('effect/Logger');
var LogLevel = require('effect/LogLevel');
var Data = require('effect/Data');
var types_cjs = require('../internal/types.cjs');
var Arr = require('effect/Array');
var Predicate = require('effect/Predicate');
var mimeTypes = require('@uploadthing/mime-types');
var Function = require('effect/Function');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return n;
}

var Effect__namespace = /*#__PURE__*/_interopNamespace(Effect);
var S__namespace = /*#__PURE__*/_interopNamespace(S);
var Config__namespace = /*#__PURE__*/_interopNamespace(Config);
var Context__namespace = /*#__PURE__*/_interopNamespace(Context);
var Layer__namespace = /*#__PURE__*/_interopNamespace(Layer);
var ManagedRuntime__namespace = /*#__PURE__*/_interopNamespace(ManagedRuntime);
var Match__namespace = /*#__PURE__*/_interopNamespace(Match);
var ConfigProvider__namespace = /*#__PURE__*/_interopNamespace(ConfigProvider);
var Stream__namespace = /*#__PURE__*/_interopNamespace(Stream);
var Logger__namespace = /*#__PURE__*/_interopNamespace(Logger);
var LogLevel__namespace = /*#__PURE__*/_interopNamespace(LogLevel);
var Data__namespace = /*#__PURE__*/_interopNamespace(Data);
var Arr__namespace = /*#__PURE__*/_interopNamespace(Arr);
var Predicate__namespace = /*#__PURE__*/_interopNamespace(Predicate);

var version = "7.0.2";

S__namespace.Literal(...shared.ValidContentDispositions);
S__namespace.Literal(...shared.ValidACLs);
/**
 * Valid options for the `?actionType` query param
 */ const ActionType = S__namespace.Literal("upload");
/**
 * Valid options for the `uploadthing-hook` header
 * for requests coming from UT server
 */ const UploadThingHook = S__namespace.Literal("callback", "error");
/**
 * =============================================================================
 * =========================== Configuration ===================================
 * =============================================================================
 */ const DecodeString = S__namespace.transform(S__namespace.Uint8ArrayFromSelf, S__namespace.String, {
    decode: (data)=>new TextDecoder().decode(data),
    encode: (data)=>new TextEncoder().encode(data)
});
const ParsedToken = S__namespace.Struct({
    apiKey: S__namespace.String.pipe(S__namespace.startsWith("sk_")),
    appId: S__namespace.String,
    regions: S__namespace.NonEmptyArray(S__namespace.String),
    ingestHost: S__namespace.String.pipe(S__namespace.optionalWith({
        default: ()=>"ingest.uploadthing.com"
    }))
});
const UploadThingToken = S__namespace.Uint8ArrayFromBase64.pipe(S__namespace.compose(DecodeString), S__namespace.compose(S__namespace.parseJson(ParsedToken)));
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ /**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */ class FileUploadData extends S__namespace.Class("FileUploadData")({
    name: S__namespace.String,
    size: S__namespace.Number,
    type: S__namespace.String,
    lastModified: S__namespace.Number.pipe(S__namespace.optional)
}) {
}
/**
 * `.middleware()` can add a customId to the incoming file data
 */ class FileUploadDataWithCustomId extends FileUploadData.extend("FileUploadDataWithCustomId")({
    customId: S__namespace.NullOr(S__namespace.String)
}) {
}
/**
 * When files are uploaded, we get back
 * - a key
 * - a direct URL for the file
 * - an app-specific URL for the file (useful for scoping eg. for optimization allowed origins)
 */ class UploadedFileData extends FileUploadDataWithCustomId.extend("UploadedFileData")({
    key: S__namespace.String,
    url: S__namespace.String,
    appUrl: S__namespace.String
}) {
}
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ class NewPresignedUrl extends S__namespace.Class("NewPresignedUrl")({
    url: S__namespace.String,
    key: S__namespace.String,
    customId: S__namespace.NullOr(S__namespace.String),
    name: S__namespace.String
}) {
}
class MetadataFetchStreamPart extends S__namespace.Class("MetadataFetchStreamPart")({
    payload: S__namespace.String,
    signature: S__namespace.String,
    hook: UploadThingHook
}) {
}
class MetadataFetchResponse extends S__namespace.Class("MetadataFetchResponse")({
    ok: S__namespace.Boolean
}) {
}
class CallbackResultResponse extends S__namespace.Class("CallbackResultResponse")({
    ok: S__namespace.Boolean
}) {
}
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ class UploadActionPayload extends S__namespace.Class("UploadActionPayload")({
    files: S__namespace.Array(FileUploadData),
    input: S__namespace.Unknown
}) {
}

/**
 * Merge in `import.meta.env` to the built-in `process.env` provider
 * Prefix keys with `UPLOADTHING_` so we can reference just the name.
 * @example
 * process.env.UPLOADTHING_TOKEN = "foo"
 * Config.string("token"); // Config<"foo">
 */ const envProvider = ConfigProvider__namespace.fromEnv().pipe(ConfigProvider__namespace.orElse(()=>ConfigProvider__namespace.fromMap(new Map(Object.entries(shared.filterDefinedObjectValues(// fuck this I give up. import.meta is a mistake, someone else can fix it
    undefined ?? {}))), {
        pathDelim: "_"
    })), ConfigProvider__namespace.nested("uploadthing"), ConfigProvider__namespace.constantCase);
/**
 * Config provider that merges the options from the object
 * and environment variables prefixed with `UPLOADTHING_`.
 * @remarks Options take precedence over environment variables.
 */ const configProvider = (options)=>ConfigProvider__namespace.fromJson(options ?? {}).pipe(ConfigProvider__namespace.orElse(()=>envProvider));
const IsDevelopment = Config__namespace.boolean("isDev").pipe(Config__namespace.orElse(()=>Config__namespace.succeed(typeof process !== "undefined" ? process.env.NODE_ENV : undefined).pipe(Config__namespace.map((_)=>_ === "development"))), Config__namespace.withDefault(false));
const UTToken = S__namespace.Config("token", UploadThingToken).pipe(Effect__namespace.catchTags({
    ConfigError: (e)=>new shared.UploadThingError({
            code: e._op === "InvalidData" ? "INVALID_SERVER_CONFIG" : "MISSING_ENV",
            message: e._op === "InvalidData" ? "Invalid token. A token is a base64 encoded JSON object matching { apiKey: string, appId: string, regions: string[] }." : "Missing token. Please set the `UPLOADTHING_TOKEN` environment variable or provide a token manually through config.",
            cause: e
        })
}));
const ApiUrl = Config__namespace.string("apiUrl").pipe(Config__namespace.withDefault("https://api.uploadthing.com"), Config__namespace.mapAttempt((_)=>new URL(_)), Config__namespace.map((url)=>url.href.replace(/\/$/, "")));
const IngestUrl = Effect__namespace.gen(function*() {
    const { regions, ingestHost } = yield* UTToken;
    const region = regions[0]; // Currently only support 1 region per app
    return yield* Config__namespace.string("ingestUrl").pipe(Config__namespace.withDefault(`https://${region}.${ingestHost}`), Config__namespace.mapAttempt((_)=>new URL(_)), Config__namespace.map((url)=>url.href.replace(/\/$/, "")));
});

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const handleJsonLineStream = (schema, onChunk)=>(stream)=>{
        let buf = "";
        return stream.pipe(Stream__namespace.decodeText(), Stream__namespace.mapEffect((chunk)=>Effect__namespace.gen(function*() {
                buf += chunk;
                // Scan buffer for newlines
                const parts = buf.split("\n");
                const validChunks = [];
                for (const part of parts){
                    try {
                        // Attempt to parse chunk as JSON
                        validChunks.push(JSON.parse(part));
                        // Advance buffer if parsing succeeded
                        buf = buf.slice(part.length + 1);
                    } catch  {
                    //
                    }
                }
                yield* Effect__namespace.logDebug("Received chunks").pipe(Effect__namespace.annotateLogs("chunk", chunk), Effect__namespace.annotateLogs("parsedChunks", validChunks), Effect__namespace.annotateLogs("buf", buf));
                return validChunks;
            })), Stream__namespace.mapEffect(S__namespace.decodeUnknown(S__namespace.Array(schema))), Stream__namespace.mapEffect(Effect__namespace.forEach((part)=>onChunk(part))), Stream__namespace.runDrain, Effect__namespace.withLogSpan("handleJsonLineStream"));
    };

const withMinimalLogLevel = Config__namespace.logLevel("logLevel").pipe(Config__namespace.withDefault(LogLevel__namespace.Info), Effect__namespace.andThen((level)=>Logger__namespace.minimumLogLevel(level)), Effect__namespace.tapError((e)=>Effect__namespace.logError("Invalid log level").pipe(Effect__namespace.annotateLogs("error", e))), Effect__namespace.catchTag("ConfigError", (e)=>new shared.UploadThingError({
        code: "INVALID_SERVER_CONFIG",
        message: "Invalid server configuration",
        cause: e
    })), Layer__namespace.unwrapEffect);

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

class FileSizeMismatch extends Data__namespace.Error {
    constructor(type, max, actual){
        const reason = `You uploaded a ${type} file that was ${shared.bytesToFileSize(actual)}, but the limit for that type is ${max}`;
        super({
            reason
        });
        this._tag = "FileSizeMismatch";
        this.name = "FileSizeMismatchError";
    }
}
class FileCountMismatch extends Data__namespace.Error {
    constructor(type, boundtype, bound, actual){
        const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;
        super({
            reason
        });
        this._tag = "FileCountMismatch";
        this.name = "FileCountMismatchError";
    }
}
// Verify that the uploaded files doesn't violate the route config,
// e.g. uploading more videos than allowed, or a file that is larger than allowed.
// This is double-checked on infra side, but we want to fail early to avoid network latency.
const assertFilesMeetConfig = (files, routeConfig)=>Effect__namespace.gen(function*() {
        const counts = {};
        for (const file of files){
            const type = yield* shared.getTypeFromFileName(file.name, shared.objectKeys(routeConfig));
            counts[type] = (counts[type] ?? 0) + 1;
            const sizeLimit = routeConfig[type]?.maxFileSize;
            if (!sizeLimit) {
                return yield* new shared.InvalidRouteConfigError(type, "maxFileSize");
            }
            const sizeLimitBytes = yield* shared.fileSizeToBytes(sizeLimit);
            if (file.size > sizeLimitBytes) {
                return yield* new FileSizeMismatch(type, sizeLimit, file.size);
            }
        }
        for(const _key in counts){
            const key = _key;
            const config = routeConfig[key];
            if (!config) return yield* new shared.InvalidRouteConfigError(key);
            const count = counts[key];
            const min = config.minFileCount;
            const max = config.maxFileCount;
            if (min > max) {
                return yield* new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid config during file count - minFileCount > maxFileCount",
                    cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`
                });
            }
            if (count < min) {
                return yield* new FileCountMismatch(key, "minimum", min, count);
            }
            if (count > max) {
                return yield* new FileCountMismatch(key, "maximum", max, count);
            }
        }
        return null;
    });
const extractRouterConfig$1 = (router)=>Effect__namespace.forEach(shared.objectKeys(router), (slug)=>Effect__namespace.map(shared.fillInputRouteConfig(router[slug]._def.routerConfig), (config)=>({
                slug,
                config
            })));

class MiddlewareArguments extends Context__namespace.Tag("uploadthing/MiddlewareArguments")() {
}
const makeAdapterHandler = (makeMiddlewareArgs, toRequest, opts, beAdapter)=>{
    const layer = Layer__namespace.provide(Layer__namespace.mergeAll(effectLog.PrettyLogger.layer({
        showFiberId: false
    }), withMinimalLogLevel, platform.HttpClient.layer, Layer__namespace.succeed(platform.HttpClient.Fetch, opts.config?.fetch)), Layer__namespace.setConfigProvider(configProvider(opts.config)));
    const managed = ManagedRuntime__namespace.make(layer);
    const handle = Effect__namespace.promise(()=>managed.runtime().then(platform.HttpApp.toWebHandlerRuntime));
    const app = (...args)=>Effect__namespace.map(Effect__namespace.promise(()=>managed.runPromise(createRequestHandler(opts, beAdapter))), Effect__namespace.provideServiceEffect(MiddlewareArguments, makeMiddlewareArgs(...args)));
    return async (...args)=>await handle.pipe(Effect__namespace.ap(app(...args)), Effect__namespace.ap(toRequest(...args)), Effect__namespace.withLogSpan("requestHandler"), managed.runPromise);
};
const createRequestHandler = (opts, beAdapter)=>Effect__namespace.gen(function*() {
        const isDevelopment = yield* IsDevelopment;
        const routerConfig = yield* extractRouterConfig$1(opts.router);
        const handleDaemon = (()=>{
            if (opts.config?.handleDaemonPromise) {
                return opts.config.handleDaemonPromise;
            }
            return isDevelopment ? "void" : "await";
        })();
        if (isDevelopment && handleDaemon === "await") {
            return yield* new shared.UploadThingError({
                code: "INVALID_SERVER_CONFIG",
                message: 'handleDaemonPromise: "await" is forbidden in development.'
            });
        }
        const GET = Effect__namespace.gen(function*() {
            return yield* platform.HttpServerResponse.json(routerConfig);
        });
        const POST = Effect__namespace.gen(function*() {
            const { "uploadthing-hook": uploadthingHook, "x-uploadthing-package": fePackage, "x-uploadthing-version": clientVersion } = yield* platform.HttpServerRequest.schemaHeaders(S__namespace.Struct({
                "uploadthing-hook": UploadThingHook.pipe(S__namespace.optional),
                "x-uploadthing-package": S__namespace.String.pipe(S__namespace.optionalWith({
                    default: ()=>"unknown"
                })),
                "x-uploadthing-version": S__namespace.String.pipe(S__namespace.optionalWith({
                    default: ()=>version
                }))
            }));
            if (clientVersion !== version) {
                const msg = `Server version: ${version}, Client version: ${clientVersion}`;
                yield* Effect__namespace.logError(msg);
                return yield* new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Client version mismatch",
                    cause: msg
                });
            }
            const { slug, actionType } = yield* platform.HttpRouter.schemaParams(S__namespace.Struct({
                actionType: ActionType.pipe(S__namespace.optional),
                slug: S__namespace.String
            }));
            const uploadable = opts.router[slug];
            if (!uploadable) {
                const msg = `No file route found for slug ${slug}`;
                yield* Effect__namespace.logError(msg);
                return yield* new shared.UploadThingError({
                    code: "NOT_FOUND",
                    message: msg
                });
            }
            const { body, fiber } = yield* Match__namespace.value({
                actionType,
                uploadthingHook
            }).pipe(Match__namespace.when({
                actionType: "upload",
                uploadthingHook: undefined
            }, ()=>handleUploadAction({
                    uploadable,
                    fePackage,
                    beAdapter,
                    slug
                })), Match__namespace.when({
                actionType: undefined,
                uploadthingHook: "callback"
            }, ()=>handleCallbackRequest({
                    uploadable,
                    fePackage,
                    beAdapter
                })), Match__namespace.when({
                actionType: undefined,
                uploadthingHook: "error"
            }, ()=>handleErrorRequest({
                    uploadable
                })), Match__namespace.orElse(()=>Effect__namespace.succeed({
                    body: null,
                    fiber: null
                })));
            if (fiber) {
                yield* Effect__namespace.logDebug("Running fiber as daemon").pipe(Effect__namespace.annotateLogs("handleDaemon", handleDaemon));
                if (handleDaemon === "void") ; else if (handleDaemon === "await") {
                    yield* fiber.await;
                } else if (typeof handleDaemon === "function") {
                    handleDaemon(Effect__namespace.runPromise(fiber.await));
                }
            }
            yield* Effect__namespace.logDebug("Sending response").pipe(Effect__namespace.annotateLogs("body", body));
            return yield* platform.HttpServerResponse.json(body);
        }).pipe(Effect__namespace.catchTags({
            ParseError: (e)=>platform.HttpServerResponse.json(formatError(new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid input",
                    cause: e.message
                }), opts.router), {
                    status: 400
                }),
            UploadThingError: (e)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                platform.HttpServerResponse.json(formatError(e, opts.router), {
                    status: shared.getStatusCodeFromError(e)
                })
        }));
        const appendResponseHeaders = Effect__namespace.map(platform.HttpServerResponse.setHeader("x-uploadthing-version", version));
        return platform.HttpRouter.empty.pipe(platform.HttpRouter.get("*", GET), platform.HttpRouter.post("*", POST), platform.HttpRouter.use(appendResponseHeaders));
    }).pipe(Effect__namespace.withLogSpan("createRequestHandler"));
const handleErrorRequest = (opts)=>Effect__namespace.gen(function*() {
        const { uploadable } = opts;
        const request = yield* platform.HttpServerRequest.HttpServerRequest;
        const { apiKey } = yield* UTToken;
        const verified = yield* shared.verifySignature((yield* request.text), request.headers["x-uploadthing-signature"], apiKey);
        yield* Effect__namespace.logDebug(`Signature verified: ${verified}`);
        if (!verified) {
            yield* Effect__namespace.logError("Invalid signature");
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            });
        }
        const requestInput = yield* platform.HttpServerRequest.schemaBodyJson(S__namespace.Struct({
            fileKey: S__namespace.String,
            error: S__namespace.String
        }));
        yield* Effect__namespace.logDebug("Handling error callback request with input:").pipe(Effect__namespace.annotateLogs("json", requestInput));
        const fiber = yield* Effect__namespace.tryPromise({
            try: async ()=>uploadable._def.onUploadError({
                    error: new shared.UploadThingError({
                        code: "UPLOAD_FAILED",
                        message: `Upload failed for ${requestInput.fileKey}: ${requestInput.error}`
                    }),
                    fileKey: requestInput.fileKey
                }),
            catch: (error)=>new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run onUploadError",
                    cause: error
                })
        }).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("Failed to run onUploadError. You probably shouldn't be throwing errors here.").pipe(Effect__namespace.annotateLogs("error", error)))).pipe(Effect__namespace.ignoreLogged, Effect__namespace.forkDaemon);
        return {
            body: null,
            fiber
        };
    }).pipe(Effect__namespace.withLogSpan("handleErrorRequest"));
const handleCallbackRequest = (opts)=>Effect__namespace.gen(function*() {
        const { uploadable, fePackage, beAdapter } = opts;
        const request = yield* platform.HttpServerRequest.HttpServerRequest;
        const { apiKey } = yield* UTToken;
        const verified = yield* shared.verifySignature((yield* request.text), request.headers["x-uploadthing-signature"], apiKey);
        yield* Effect__namespace.logDebug(`Signature verified: ${verified}`);
        if (!verified) {
            yield* Effect__namespace.logError("Invalid signature");
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            });
        }
        const requestInput = yield* platform.HttpServerRequest.schemaBodyJson(S__namespace.Struct({
            status: S__namespace.String,
            file: UploadedFileData,
            metadata: S__namespace.Record({
                key: S__namespace.String,
                value: S__namespace.Unknown
            })
        }));
        yield* Effect__namespace.logDebug("Handling callback request with input:").pipe(Effect__namespace.annotateLogs("json", requestInput));
        /**
     * Run `.onUploadComplete` as a daemon to prevent the
     * request from UT to potentially timeout.
     */ const fiber = yield* Effect__namespace.gen(function*() {
            const serverData = yield* Effect__namespace.tryPromise({
                try: async ()=>uploadable.resolver({
                        file: requestInput.file,
                        metadata: requestInput.metadata
                    }),
                catch: (error)=>new shared.UploadThingError({
                        code: "INTERNAL_SERVER_ERROR",
                        message: "Failed to run onUploadComplete. You probably shouldn't be throwing errors here.",
                        cause: error
                    })
            });
            const payload = {
                fileKey: requestInput.file.key,
                callbackData: serverData ?? null
            };
            yield* Effect__namespace.logDebug("'onUploadComplete' callback finished. Sending response to UploadThing:").pipe(Effect__namespace.annotateLogs("callbackData", payload));
            const baseUrl = yield* IngestUrl;
            const httpClient = yield* platform.HttpClient.HttpClient;
            yield* platform.HttpClientRequest.post(`/callback-result`).pipe(platform.HttpClientRequest.prependUrl(baseUrl), platform.HttpClientRequest.setHeaders({
                "x-uploadthing-api-key": apiKey,
                "x-uploadthing-version": version,
                "x-uploadthing-be-adapter": beAdapter,
                "x-uploadthing-fe-package": fePackage
            }), platform.HttpClientRequest.jsonBody(payload), Effect__namespace.flatMap(platform.HttpClient.filterStatusOk(httpClient)), Effect__namespace.tapErrorTag("ResponseError", ({ response: res })=>Effect__namespace.flatMap(res.json, (json)=>Effect__namespace.logError(`Failed to register callback result (${res.status})`).pipe(Effect__namespace.annotateLogs("error", json)))), platform.HttpClientResponse.schemaBodyJsonScoped(CallbackResultResponse), Effect__namespace.tap(Effect__namespace.log("Sent callback result to UploadThing")));
        }).pipe(Effect__namespace.ignoreLogged, Effect__namespace.forkDaemon);
        return {
            body: null,
            fiber
        };
    }).pipe(Effect__namespace.withLogSpan("handleCallbackRequest"));
const runRouteMiddleware = (opts)=>Effect__namespace.gen(function*() {
        const middlewareArgs = yield* MiddlewareArguments;
        const { json: { files, input }, uploadable } = opts;
        yield* Effect__namespace.logDebug("Running middleware");
        const metadata = yield* Effect__namespace.tryPromise({
            try: async ()=>uploadable._def.middleware({
                    ...middlewareArgs,
                    input,
                    files
                }),
            catch: (error)=>error instanceof shared.UploadThingError ? error : new shared.UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run middleware",
                    cause: error
                })
        });
        if (metadata[types_cjs.UTFiles] && metadata[types_cjs.UTFiles].length !== files.length) {
            const msg = `Expected files override to have the same length as original files, got ${metadata[types_cjs.UTFiles].length} but expected ${files.length}`;
            yield* Effect__namespace.logError(msg);
            return yield* new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
            });
        }
        // Attach customIds from middleware to the files
        const filesWithCustomIds = yield* Effect__namespace.forEach(files, (file, idx)=>Effect__namespace.gen(function*() {
                const theirs = metadata[types_cjs.UTFiles]?.[idx];
                if (theirs && theirs.size !== file.size) {
                    yield* Effect__namespace.logWarning("File size mismatch. Reverting to original size");
                }
                return {
                    name: theirs?.name ?? file.name,
                    size: file.size,
                    type: file.type,
                    customId: theirs?.customId,
                    lastModified: theirs?.lastModified ?? Date.now()
                };
            }));
        return {
            metadata,
            filesWithCustomIds
        };
    }).pipe(Effect__namespace.withLogSpan("runRouteMiddleware"));
const handleUploadAction = (opts)=>Effect__namespace.gen(function*() {
        const httpClient = yield* platform.HttpClient.HttpClient;
        const { uploadable, fePackage, beAdapter, slug } = opts;
        const json = yield* platform.HttpServerRequest.schemaBodyJson(UploadActionPayload);
        yield* Effect__namespace.logDebug("Handling upload request").pipe(Effect__namespace.annotateLogs("json", json));
        // validate the input
        yield* Effect__namespace.logDebug("Parsing user input");
        const inputParser = uploadable._def.inputParser;
        const parsedInput = yield* Effect__namespace.tryPromise({
            try: async ()=>getParseFn(inputParser)(json.input),
            catch: (error)=>new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid input",
                    cause: error
                })
        });
        yield* Effect__namespace.logDebug("Input parsed successfully").pipe(Effect__namespace.annotateLogs("input", parsedInput));
        const { metadata, filesWithCustomIds } = yield* runRouteMiddleware({
            json: {
                input: parsedInput,
                files: json.files
            },
            uploadable
        });
        yield* Effect__namespace.logDebug("Parsing route config").pipe(Effect__namespace.annotateLogs("routerConfig", uploadable._def.routerConfig));
        const parsedConfig = yield* shared.fillInputRouteConfig(uploadable._def.routerConfig).pipe(Effect__namespace.catchTag("InvalidRouteConfig", (err)=>new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid route config",
                cause: err
            })));
        yield* Effect__namespace.logDebug("Route config parsed successfully").pipe(Effect__namespace.annotateLogs("routeConfig", parsedConfig));
        yield* Effect__namespace.logDebug("Validating files meet the config requirements").pipe(Effect__namespace.annotateLogs("files", json.files));
        yield* assertFilesMeetConfig(json.files, parsedConfig).pipe(Effect__namespace.mapError((e)=>new shared.UploadThingError({
                code: "BAD_REQUEST",
                message: `Invalid config: ${e._tag}`,
                cause: "reason" in e ? e.reason : e.message
            })));
        yield* Effect__namespace.logDebug("Files validated.");
        const fileUploadRequests = yield* Effect__namespace.forEach(filesWithCustomIds, (file)=>Effect__namespace.map(shared.getTypeFromFileName(file.name, shared.objectKeys(parsedConfig)), (type)=>({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified,
                    customId: file.customId,
                    contentDisposition: parsedConfig[type]?.contentDisposition ?? "inline",
                    acl: parsedConfig[type]?.acl
                }))).pipe(Effect__namespace.catchTags({
            /** Shouldn't happen since config is validated above so just dying is fine I think */ InvalidFileType: (e)=>Effect__namespace.die(e),
            UnknownFileType: (e)=>Effect__namespace.die(e)
        }));
        const routeOptions = uploadable._def.routeOptions;
        const { apiKey, appId } = yield* UTToken;
        const ingestUrl = yield* IngestUrl;
        const isDev = yield* IsDevelopment;
        yield* Effect__namespace.logDebug("Generating presigned URLs").pipe(Effect__namespace.annotateLogs("fileUploadRequests", fileUploadRequests), Effect__namespace.annotateLogs("ingestUrl", ingestUrl));
        const presignedUrls = yield* Effect__namespace.forEach(fileUploadRequests, (file)=>Effect__namespace.gen(function*() {
                const key = yield* shared.generateKey(file, appId, routeOptions.getFileHashParts);
                const url = yield* shared.generateSignedURL(`${ingestUrl}/${key}`, apiKey, {
                    ttlInSeconds: routeOptions.presignedURLTTL,
                    data: {
                        "x-ut-identifier": appId,
                        "x-ut-file-name": file.name,
                        "x-ut-file-size": file.size,
                        "x-ut-file-type": file.type,
                        "x-ut-slug": slug,
                        "x-ut-custom-id": file.customId,
                        "x-ut-content-disposition": file.contentDisposition,
                        "x-ut-acl": file.acl
                    }
                });
                return {
                    url,
                    key
                };
            }), {
            concurrency: "unbounded"
        });
        const serverReq = yield* platform.HttpServerRequest.HttpServerRequest;
        const requestUrl = yield* platform.HttpServerRequest.toURL(serverReq);
        const devHookRequest = yield* Config__namespace.string("callbackUrl").pipe(Config__namespace.withDefault(requestUrl.origin + requestUrl.pathname), Effect__namespace.map((url)=>platform.HttpClientRequest.post(url).pipe(platform.HttpClientRequest.appendUrlParam("slug", slug))));
        const metadataRequest = platform.HttpClientRequest.post("/route-metadata").pipe(platform.HttpClientRequest.prependUrl(ingestUrl), platform.HttpClientRequest.setHeaders({
            "x-uploadthing-api-key": apiKey,
            "x-uploadthing-version": version,
            "x-uploadthing-be-adapter": beAdapter,
            "x-uploadthing-fe-package": fePackage
        }), platform.HttpClientRequest.jsonBody({
            fileKeys: presignedUrls.map(({ key })=>key),
            metadata: metadata,
            isDev,
            callbackUrl: devHookRequest.url,
            callbackSlug: slug,
            awaitServerData: routeOptions.awaitServerData ?? true
        }), Effect__namespace.flatMap(platform.HttpClient.filterStatusOk(httpClient)), Effect__namespace.tapBoth({
            onSuccess: (res)=>Effect__namespace.logDebug("Registerred metadata").pipe(Effect__namespace.annotateLogs("response", res)),
            onFailure: (err)=>err._tag === "ResponseError" ? Effect__namespace.flatMap(err.response.json, (json)=>Effect__namespace.logError(`Failed to register metadata (${err.response.status})`).pipe(Effect__namespace.annotateLogs("response", err.response), Effect__namespace.annotateLogs("json", json))) : Effect__namespace.logError("Failed to register metadata").pipe(Effect__namespace.annotateLogs("error", err))
        }));
        // Send metadata to UT server (non blocking as a daemon)
        // In dev, keep the stream open and simulate the callback requests as
        // files complete uploading
        const fiber = yield* Effect__namespace.if(isDev, {
            onTrue: ()=>metadataRequest.pipe(platform.HttpClientResponse.stream, handleJsonLineStream(MetadataFetchStreamPart, ({ payload, signature, hook })=>devHookRequest.pipe(platform.HttpClientRequest.setHeaders({
                        "uploadthing-hook": hook,
                        "x-uploadthing-signature": signature
                    }), platform.HttpClientRequest.setBody(platform.HttpBody.text(payload, "application/json")), httpClient, platform.HttpClientResponse.arrayBuffer, Effect__namespace.asVoid, Effect__namespace.tap(Effect__namespace.log(`Successfully simulated '${hook}' event`)), Effect__namespace.ignoreLogged))),
            onFalse: ()=>metadataRequest.pipe(platform.HttpClientResponse.schemaBodyJsonScoped(MetadataFetchResponse))
        }).pipe(Effect__namespace.forkDaemon);
        const presigneds = presignedUrls.map((p, i)=>({
                url: p.url,
                key: p.key,
                name: fileUploadRequests[i].name,
                customId: fileUploadRequests[i].customId ?? null
            }));
        yield* Effect__namespace.logInfo("Sending presigned URLs to client").pipe(Effect__namespace.annotateLogs("presignedUrls", presigneds));
        return {
            body: presigneds,
            fiber
        };
    }).pipe(Effect__namespace.withLogSpan("handleUploadAction"));

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        routeOptions: {
            awaitServerData: true
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>{
        // noop
        },
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input, config)=>{
        return internalCreateBuilder({
            routerConfig: input,
            routeOptions: config ?? {},
            ...opts
        });
    };
}

/**
 * Extension of the Blob class that simplifies setting the `name` and `customId` properties,
 * similar to the built-in File class from Node > 20.
 */ class UTFile extends Blob {
    constructor(parts, name, options){
        const optionsWithDefaults = {
            ...options,
            type: options?.type ?? (mimeTypes.lookup(name) || "application/octet-stream"),
            lastModified: options?.lastModified ?? Date.now()
        };
        super(parts, optionsWithDefaults);
        this.name = name;
        this.customId = optionsWithDefaults.customId;
        this.lastModified = optionsWithDefaults.lastModified;
    }
}

const uploadWithoutProgress = (file, presigned)=>Effect__namespace.gen(function*() {
        const formData = new FormData();
        formData.append("file", file); // File data **MUST GO LAST**
        const httpClient = yield* platform.HttpClient.HttpClient;
        const json = yield* platform.HttpClientRequest.put(presigned.url).pipe(platform.HttpClientRequest.formDataBody(formData), platform.HttpClientRequest.setHeader("Range", "bytes=0-"), platform.HttpClient.filterStatusOk(httpClient), Effect__namespace.mapError((e)=>new shared.UploadThingError({
                code: "UPLOAD_FAILED",
                message: "Failed to upload file",
                cause: e
            })), platform.HttpClientResponse.json, Effect__namespace.andThen(Function.unsafeCoerce));
        yield* Effect__namespace.logDebug(`File ${file.name} uploaded successfully`).pipe(Effect__namespace.annotateLogs("json", json));
        return json;
    });

function guardServerOnly() {
    if (typeof window !== "undefined") {
        throw new shared.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "The `utapi` can only be used on the server."
        });
    }
}
const uploadFilesInternal = (input)=>getPresignedUrls(input).pipe(Effect__namespace.andThen((presigneds)=>Effect__namespace.forEach(presigneds, (file)=>uploadFile(file).pipe(Effect__namespace.tapError((error)=>Effect__namespace.logError("Upload failed").pipe(Effect__namespace.annotateLogs("error", error))), Effect__namespace.match({
                onFailure: (error)=>({
                        data: null,
                        error: shared.UploadThingError.toObject(error instanceof shared.UploadThingError ? error : new shared.UploadThingError({
                            message: "Failed to upload file.",
                            code: "BAD_REQUEST",
                            cause: error
                        }))
                    }),
                onSuccess: (data)=>({
                        data,
                        error: null
                    })
            })), {
            concurrency: 10
        })));
/**
 * FIXME: downloading everything into memory and then upload
 * isn't the best. We should support streams so we can download
 * just as much as we need at any time.
 */ const downloadFiles = (urls, downloadErrors)=>Effect__namespace.forEach(urls, (_url, idx)=>Effect__namespace.gen(function*() {
            let url = shared.isObject(_url) ? _url.url : _url;
            if (typeof url === "string") {
                // since dataurls will result in name being too long, tell the user
                // to use uploadFiles instead.
                if (url.startsWith("data:")) {
                    downloadErrors[idx] = shared.UploadThingError.toObject(new shared.UploadThingError({
                        code: "BAD_REQUEST",
                        message: "Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only."
                    }));
                    return null;
                }
            }
            url = new URL(url);
            const { name = url.pathname.split("/").pop() ?? "unknown-filename", customId = undefined } = shared.isObject(_url) ? _url : {};
            const arrayBuffer = yield* platform.HttpClientRequest.get(url).pipe(platform.HttpClientRequest.modify({
                headers: {}
            }), platform.HttpClient.filterStatusOk((yield* platform.HttpClient.HttpClient)), platform.HttpClientResponse.arrayBuffer, Effect__namespace.mapError((error)=>{
                downloadErrors[idx] = shared.UploadThingError.toObject(new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Failed to download requested file.",
                    cause: error
                }));
                return Effect__namespace.succeed(undefined);
            }));
            return new UTFile([
                arrayBuffer
            ], name, {
                customId,
                lastModified: Date.now()
            });
        }).pipe(Effect__namespace.withLogSpan("downloadFile")), {
        concurrency: 10
    });
const getPresignedUrls = (input)=>Effect__namespace.gen(function*() {
        const { files, contentDisposition, acl } = input;
        yield* Effect__namespace.logDebug("Generating presigned URLs for files").pipe(Effect__namespace.annotateLogs("files", files));
        const { apiKey, appId } = yield* UTToken;
        const baseUrl = yield* IngestUrl;
        const presigneds = yield* Effect__namespace.forEach(files, (file)=>Effect__namespace.gen(function*() {
                const key = yield* shared.generateKey(file, appId);
                const url = yield* shared.generateSignedURL(`${baseUrl}/${key}`, apiKey, {
                    // ttlInSeconds: routeOptions.presignedURLTTL,
                    data: {
                        "x-ut-identifier": appId,
                        "x-ut-file-name": file.name,
                        "x-ut-file-size": file.size,
                        "x-ut-file-type": file.type,
                        "x-ut-custom-id": file.customId,
                        "x-ut-content-disposition": contentDisposition,
                        "x-ut-acl": acl
                    }
                });
                return {
                    url,
                    key
                };
            }));
        yield* Effect__namespace.logDebug("Generated presigned URLs").pipe(Effect__namespace.annotateLogs("presigneds", presigneds));
        return files.map((file, i)=>({
                file,
                presigned: presigneds[i]
            }));
    }).pipe(Effect__namespace.withLogSpan("getPresignedUrls"));
const uploadFile = (input)=>Effect__namespace.gen(function*() {
        const { file, presigned } = input;
        const { url, appUrl } = yield* uploadWithoutProgress(file, presigned);
        return {
            key: presigned.key,
            url: url,
            appUrl: appUrl,
            lastModified: file.lastModified ?? Date.now(),
            name: file.name,
            size: file.size,
            type: file.type,
            customId: file.customId ?? null
        };
    }).pipe(Effect__namespace.withLogSpan("uploadFile"));

class UTApi {
    constructor(opts){
        this.opts = opts;
        this.requestUploadThing = (pathname, body, responseSchema)=>Effect__namespace.gen(this, function*() {
                const { apiKey } = yield* UTToken;
                const baseUrl = yield* ApiUrl;
                const httpClient = yield* platform.HttpClient.HttpClient;
                return yield* platform.HttpClientRequest.post(pathname).pipe(platform.HttpClientRequest.prependUrl(baseUrl), platform.HttpClientRequest.unsafeJsonBody(body), platform.HttpClientRequest.setHeaders({
                    "x-uploadthing-version": version,
                    "x-uploadthing-be-adapter": "server-sdk",
                    "x-uploadthing-api-key": apiKey
                }), platform.HttpClient.filterStatusOk(httpClient), Effect__namespace.tapBoth({
                    onSuccess: (res)=>Effect__namespace.logDebug(`UT Response`).pipe(Effect__namespace.annotateLogs("res", res)),
                    onFailure: (err)=>Effect__namespace.logError("UploadThing error").pipe(Effect__namespace.annotateLogs("error", err))
                }), platform.HttpClientResponse.schemaBodyJsonScoped(responseSchema));
            }).pipe(Effect__namespace.withLogSpan("utapi.#requestUploadThing"));
        this.executeAsync = (program, signal)=>{
            return program.pipe(Effect__namespace.provide(effectLog.PrettyLogger.layer({
                showFiberId: false
            })), Effect__namespace.provide(withMinimalLogLevel), Effect__namespace.provide(platform.HttpClient.layer), Effect__namespace.provide(Layer__namespace.effect(platform.HttpClient.Fetch, Effect__namespace.succeed(this.fetch))), Effect__namespace.provide(Layer__namespace.setConfigProvider(configProvider(this.opts))), Effect__namespace.withLogSpan("utapi.#executeAsync"), (e)=>Effect__namespace.runPromise(e, signal ? {
                    signal
                } : undefined));
        };
        this./**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   *
   * @example
   * await deleteFiles("myCustomIdentifier", { keyType: "customId" })
   */ deleteFiles = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class DeleteFileResponse extends S__namespace.Class("DeleteFileResponse")({
                success: S__namespace.Boolean,
                deletedCount: S__namespace.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/deleteFiles", keyType === "fileKey" ? {
                fileKeys: shared.asArray(keys)
            } : {
                customIds: shared.asArray(keys)
            }, DeleteFileResponse).pipe(Effect__namespace.withLogSpan("deleteFiles")));
        };
        this./**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */ getFileUrls = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class GetFileUrlResponse extends S__namespace.Class("GetFileUrlResponse")({
                data: S__namespace.Array(S__namespace.Struct({
                    key: S__namespace.String,
                    url: S__namespace.String
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getFileUrl", keyType === "fileKey" ? {
                fileKeys: keys
            } : {
                customIds: keys
            }, GetFileUrlResponse).pipe(Effect__namespace.withLogSpan("getFileUrls")));
        };
        this./**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */ listFiles = async (opts)=>{
            guardServerOnly();
            class ListFileResponse extends S__namespace.Class("ListFileResponse")({
                hasMore: S__namespace.Boolean,
                files: S__namespace.Array(S__namespace.Struct({
                    id: S__namespace.String,
                    customId: S__namespace.NullOr(S__namespace.String),
                    key: S__namespace.String,
                    name: S__namespace.String,
                    status: S__namespace.Literal("Deletion Pending", "Failed", "Uploaded", "Uploading")
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/listFiles", {
                ...opts
            }, ListFileResponse).pipe(Effect__namespace.withLogSpan("listFiles")));
        };
        this.renameFiles = async (updates)=>{
            guardServerOnly();
            class RenameFileResponse extends S__namespace.Class("RenameFileResponse")({
                success: S__namespace.Boolean
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/renameFiles", {
                updates: shared.asArray(updates)
            }, RenameFileResponse).pipe(Effect__namespace.withLogSpan("renameFiles")));
        };
        this.getUsageInfo = async ()=>{
            guardServerOnly();
            class GetUsageInfoResponse extends S__namespace.Class("GetUsageInfoResponse")({
                totalBytes: S__namespace.Number,
                appTotalBytes: S__namespace.Number,
                filesUploaded: S__namespace.Number,
                limitBytes: S__namespace.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getUsageInfo", {}, GetUsageInfoResponse).pipe(Effect__namespace.withLogSpan("getUsageInfo")));
        };
        this./** Request a presigned url for a private file(s) */ getSignedURL = async (key, opts)=>{
            guardServerOnly();
            const expiresIn = opts?.expiresIn ? shared.parseTimeToSeconds(opts.expiresIn) : undefined;
            const { keyType = this.defaultKeyType } = opts ?? {};
            if (opts?.expiresIn && isNaN(expiresIn)) {
                throw new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
                });
            }
            if (expiresIn && expiresIn > 86400 * 7) {
                throw new shared.UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be less than 7 days (604800 seconds)."
                });
            }
            class GetSignedUrlResponse extends S__namespace.Class("GetSignedUrlResponse")({
                url: S__namespace.String
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/requestFileAccess", keyType === "fileKey" ? {
                fileKey: key,
                expiresIn
            } : {
                customId: key,
                expiresIn
            }, GetSignedUrlResponse).pipe(Effect__namespace.withLogSpan("getSignedURL")));
        };
        this./**
   * Update the ACL of a file or set of files.
   *
   * @example
   * // Make a single file public
   * await utapi.updateACL("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", "public-read");
   *
   * // Make multiple files private
   * await utapi.updateACL(
   *   [
   *     "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *     "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg",
   *   ],
   *   "private",
   * );
   */ updateACL = async (keys, acl, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            const updates = shared.asArray(keys).map((key)=>{
                return keyType === "fileKey" ? {
                    fileKey: key,
                    acl
                } : {
                    customId: key,
                    acl
                };
            });
            const responseSchema = S__namespace.Struct({
                success: S__namespace.Boolean
            });
            return await this.executeAsync(this.requestUploadThing("/v6/updateACL", {
                updates
            }, responseSchema).pipe(Effect__namespace.withLogSpan("updateACL")));
        };
        // Assert some stuff
        guardServerOnly();
        this.fetch = opts?.fetch ?? globalThis.fetch;
        this.defaultKeyType = opts?.defaultKeyType ?? "fileKey";
    }
    async uploadFiles(files, opts) {
        guardServerOnly();
        const uploads = await this.executeAsync(Effect__namespace.flatMap(uploadFilesInternal({
            files: shared.asArray(files),
            contentDisposition: opts?.contentDisposition ?? "inline",
            acl: opts?.acl
        }), (ups)=>Effect__namespace.succeed(Array.isArray(files) ? ups : ups[0])).pipe(Effect__namespace.tap((res)=>Effect__namespace.logDebug("Finished uploading").pipe(Effect__namespace.annotateLogs("uploadResult", res))), Effect__namespace.withLogSpan("uploadFiles")), opts?.signal);
        return uploads;
    }
    async uploadFilesFromUrl(urls, opts) {
        guardServerOnly();
        const downloadErrors = {};
        const arr = shared.asArray(urls);
        const program = Effect__namespace.gen(function*() {
            const downloadedFiles = yield* downloadFiles(arr, downloadErrors).pipe(Effect__namespace.map((files)=>Arr__namespace.filter(files, Predicate__namespace.isNotNullable)));
            yield* Effect__namespace.logDebug(`Downloaded ${downloadedFiles.length}/${arr.length} files`).pipe(Effect__namespace.annotateLogs("downloadedFiles", downloadedFiles));
            const uploads = yield* uploadFilesInternal({
                files: downloadedFiles,
                contentDisposition: opts?.contentDisposition ?? "inline",
                acl: opts?.acl
            });
            /** Put it all back together, preserve the order of files */ const responses = arr.map((_, index)=>{
                if (downloadErrors[index]) {
                    return {
                        data: null,
                        error: downloadErrors[index]
                    };
                }
                return uploads.shift();
            });
            /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];
            yield* Effect__namespace.logDebug("Finished uploading").pipe(Effect__namespace.annotateLogs("uploadResult", uploadFileResponse), Effect__namespace.withLogSpan("utapi.uploadFilesFromUrl"));
            return uploadFileResponse;
        }).pipe(Effect__namespace.withLogSpan("uploadFilesFromUrl"));
        return await this.executeAsync(program, opts?.signal);
    }
}

const createUploadthing = (opts)=>createBuilder(opts);
const createRouteHandler = (opts)=>{
    return makeAdapterHandler((req)=>Effect__namespace.succeed({
            req,
            res: undefined,
            event: undefined
        }), (ev)=>Effect__namespace.succeed("request" in ev ? ev.request : ev), opts, "server");
};
const extractRouterConfig = (router)=>Effect__namespace.runSync(extractRouterConfig$1(router));

Object.defineProperty(exports, "UploadThingError", {
  enumerable: true,
  get: function () { return shared.UploadThingError; }
});
Object.defineProperty(exports, "UTFiles", {
  enumerable: true,
  get: function () { return types_cjs.UTFiles; }
});
exports.UTApi = UTApi;
exports.UTFile = UTFile;
exports.createRouteHandler = createRouteHandler;
exports.createUploadthing = createUploadthing;
exports.extractRouterConfig = extractRouterConfig;
