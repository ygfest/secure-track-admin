import * as Effect from 'effect/Effect';
import { ValidContentDispositions, ValidACLs, filterDefinedObjectValues, UploadThingError, objectKeys, fillInputRouteConfig, getTypeFromFileName, InvalidRouteConfigError, fileSizeToBytes, bytesToFileSize, getStatusCodeFromError, verifySignature, generateKey, generateSignedURL, isObject, asArray, parseTimeToSeconds } from '@uploadthing/shared';
export { UploadThingError } from '@uploadthing/shared';
import { HttpClient, HttpApp, HttpServerResponse, HttpServerRequest, HttpRouter, HttpClientRequest, HttpClientResponse, HttpBody } from '@effect/platform';
import * as S from '@effect/schema/Schema';
import { PrettyLogger } from 'effect-log';
import * as Config from 'effect/Config';
import * as Context from 'effect/Context';
import * as Layer from 'effect/Layer';
import * as ManagedRuntime from 'effect/ManagedRuntime';
import * as Match from 'effect/Match';
import * as ConfigProvider from 'effect/ConfigProvider';
import * as Stream from 'effect/Stream';
import * as Logger from 'effect/Logger';
import * as LogLevel from 'effect/LogLevel';
import * as Data from 'effect/Data';
import { UTFiles } from '../internal/types.js';
export { UTFiles } from '../internal/types.js';
import * as Arr from 'effect/Array';
import * as Predicate from 'effect/Predicate';
import { lookup } from '@uploadthing/mime-types';
import { unsafeCoerce } from 'effect/Function';

var version = "7.0.2";

S.Literal(...ValidContentDispositions);
S.Literal(...ValidACLs);
/**
 * Valid options for the `?actionType` query param
 */ const ActionType = S.Literal("upload");
/**
 * Valid options for the `uploadthing-hook` header
 * for requests coming from UT server
 */ const UploadThingHook = S.Literal("callback", "error");
/**
 * =============================================================================
 * =========================== Configuration ===================================
 * =============================================================================
 */ const DecodeString = S.transform(S.Uint8ArrayFromSelf, S.String, {
    decode: (data)=>new TextDecoder().decode(data),
    encode: (data)=>new TextEncoder().encode(data)
});
const ParsedToken = S.Struct({
    apiKey: S.String.pipe(S.startsWith("sk_")),
    appId: S.String,
    regions: S.NonEmptyArray(S.String),
    ingestHost: S.String.pipe(S.optionalWith({
        default: ()=>"ingest.uploadthing.com"
    }))
});
const UploadThingToken = S.Uint8ArrayFromBase64.pipe(S.compose(DecodeString), S.compose(S.parseJson(ParsedToken)));
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ /**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */ class FileUploadData extends S.Class("FileUploadData")({
    name: S.String,
    size: S.Number,
    type: S.String,
    lastModified: S.Number.pipe(S.optional)
}) {
}
/**
 * `.middleware()` can add a customId to the incoming file data
 */ class FileUploadDataWithCustomId extends FileUploadData.extend("FileUploadDataWithCustomId")({
    customId: S.NullOr(S.String)
}) {
}
/**
 * When files are uploaded, we get back
 * - a key
 * - a direct URL for the file
 * - an app-specific URL for the file (useful for scoping eg. for optimization allowed origins)
 */ class UploadedFileData extends FileUploadDataWithCustomId.extend("UploadedFileData")({
    key: S.String,
    url: S.String,
    appUrl: S.String
}) {
}
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ class NewPresignedUrl extends S.Class("NewPresignedUrl")({
    url: S.String,
    key: S.String,
    customId: S.NullOr(S.String),
    name: S.String
}) {
}
class MetadataFetchStreamPart extends S.Class("MetadataFetchStreamPart")({
    payload: S.String,
    signature: S.String,
    hook: UploadThingHook
}) {
}
class MetadataFetchResponse extends S.Class("MetadataFetchResponse")({
    ok: S.Boolean
}) {
}
class CallbackResultResponse extends S.Class("CallbackResultResponse")({
    ok: S.Boolean
}) {
}
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ class UploadActionPayload extends S.Class("UploadActionPayload")({
    files: S.Array(FileUploadData),
    input: S.Unknown
}) {
}

/**
 * Merge in `import.meta.env` to the built-in `process.env` provider
 * Prefix keys with `UPLOADTHING_` so we can reference just the name.
 * @example
 * process.env.UPLOADTHING_TOKEN = "foo"
 * Config.string("token"); // Config<"foo">
 */ const envProvider = ConfigProvider.fromEnv().pipe(ConfigProvider.orElse(()=>ConfigProvider.fromMap(new Map(Object.entries(filterDefinedObjectValues(// fuck this I give up. import.meta is a mistake, someone else can fix it
    import.meta?.env ?? {}))), {
        pathDelim: "_"
    })), ConfigProvider.nested("uploadthing"), ConfigProvider.constantCase);
/**
 * Config provider that merges the options from the object
 * and environment variables prefixed with `UPLOADTHING_`.
 * @remarks Options take precedence over environment variables.
 */ const configProvider = (options)=>ConfigProvider.fromJson(options ?? {}).pipe(ConfigProvider.orElse(()=>envProvider));
const IsDevelopment = Config.boolean("isDev").pipe(Config.orElse(()=>Config.succeed(typeof process !== "undefined" ? process.env.NODE_ENV : undefined).pipe(Config.map((_)=>_ === "development"))), Config.withDefault(false));
const UTToken = S.Config("token", UploadThingToken).pipe(Effect.catchTags({
    ConfigError: (e)=>new UploadThingError({
            code: e._op === "InvalidData" ? "INVALID_SERVER_CONFIG" : "MISSING_ENV",
            message: e._op === "InvalidData" ? "Invalid token. A token is a base64 encoded JSON object matching { apiKey: string, appId: string, regions: string[] }." : "Missing token. Please set the `UPLOADTHING_TOKEN` environment variable or provide a token manually through config.",
            cause: e
        })
}));
const ApiUrl = Config.string("apiUrl").pipe(Config.withDefault("https://api.uploadthing.com"), Config.mapAttempt((_)=>new URL(_)), Config.map((url)=>url.href.replace(/\/$/, "")));
const IngestUrl = Effect.gen(function*() {
    const { regions, ingestHost } = yield* UTToken;
    const region = regions[0]; // Currently only support 1 region per app
    return yield* Config.string("ingestUrl").pipe(Config.withDefault(`https://${region}.${ingestHost}`), Config.mapAttempt((_)=>new URL(_)), Config.map((url)=>url.href.replace(/\/$/, "")));
});

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const handleJsonLineStream = (schema, onChunk)=>(stream)=>{
        let buf = "";
        return stream.pipe(Stream.decodeText(), Stream.mapEffect((chunk)=>Effect.gen(function*() {
                buf += chunk;
                // Scan buffer for newlines
                const parts = buf.split("\n");
                const validChunks = [];
                for (const part of parts){
                    try {
                        // Attempt to parse chunk as JSON
                        validChunks.push(JSON.parse(part));
                        // Advance buffer if parsing succeeded
                        buf = buf.slice(part.length + 1);
                    } catch  {
                    //
                    }
                }
                yield* Effect.logDebug("Received chunks").pipe(Effect.annotateLogs("chunk", chunk), Effect.annotateLogs("parsedChunks", validChunks), Effect.annotateLogs("buf", buf));
                return validChunks;
            })), Stream.mapEffect(S.decodeUnknown(S.Array(schema))), Stream.mapEffect(Effect.forEach((part)=>onChunk(part))), Stream.runDrain, Effect.withLogSpan("handleJsonLineStream"));
    };

const withMinimalLogLevel = Config.logLevel("logLevel").pipe(Config.withDefault(LogLevel.Info), Effect.andThen((level)=>Logger.minimumLogLevel(level)), Effect.tapError((e)=>Effect.logError("Invalid log level").pipe(Effect.annotateLogs("error", e))), Effect.catchTag("ConfigError", (e)=>new UploadThingError({
        code: "INVALID_SERVER_CONFIG",
        message: "Invalid server configuration",
        cause: e
    })), Layer.unwrapEffect);

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

class FileSizeMismatch extends Data.Error {
    constructor(type, max, actual){
        const reason = `You uploaded a ${type} file that was ${bytesToFileSize(actual)}, but the limit for that type is ${max}`;
        super({
            reason
        });
        this._tag = "FileSizeMismatch";
        this.name = "FileSizeMismatchError";
    }
}
class FileCountMismatch extends Data.Error {
    constructor(type, boundtype, bound, actual){
        const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;
        super({
            reason
        });
        this._tag = "FileCountMismatch";
        this.name = "FileCountMismatchError";
    }
}
// Verify that the uploaded files doesn't violate the route config,
// e.g. uploading more videos than allowed, or a file that is larger than allowed.
// This is double-checked on infra side, but we want to fail early to avoid network latency.
const assertFilesMeetConfig = (files, routeConfig)=>Effect.gen(function*() {
        const counts = {};
        for (const file of files){
            const type = yield* getTypeFromFileName(file.name, objectKeys(routeConfig));
            counts[type] = (counts[type] ?? 0) + 1;
            const sizeLimit = routeConfig[type]?.maxFileSize;
            if (!sizeLimit) {
                return yield* new InvalidRouteConfigError(type, "maxFileSize");
            }
            const sizeLimitBytes = yield* fileSizeToBytes(sizeLimit);
            if (file.size > sizeLimitBytes) {
                return yield* new FileSizeMismatch(type, sizeLimit, file.size);
            }
        }
        for(const _key in counts){
            const key = _key;
            const config = routeConfig[key];
            if (!config) return yield* new InvalidRouteConfigError(key);
            const count = counts[key];
            const min = config.minFileCount;
            const max = config.maxFileCount;
            if (min > max) {
                return yield* new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid config during file count - minFileCount > maxFileCount",
                    cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`
                });
            }
            if (count < min) {
                return yield* new FileCountMismatch(key, "minimum", min, count);
            }
            if (count > max) {
                return yield* new FileCountMismatch(key, "maximum", max, count);
            }
        }
        return null;
    });
const extractRouterConfig$1 = (router)=>Effect.forEach(objectKeys(router), (slug)=>Effect.map(fillInputRouteConfig(router[slug]._def.routerConfig), (config)=>({
                slug,
                config
            })));

class MiddlewareArguments extends Context.Tag("uploadthing/MiddlewareArguments")() {
}
const makeAdapterHandler = (makeMiddlewareArgs, toRequest, opts, beAdapter)=>{
    const layer = Layer.provide(Layer.mergeAll(PrettyLogger.layer({
        showFiberId: false
    }), withMinimalLogLevel, HttpClient.layer, Layer.succeed(HttpClient.Fetch, opts.config?.fetch)), Layer.setConfigProvider(configProvider(opts.config)));
    const managed = ManagedRuntime.make(layer);
    const handle = Effect.promise(()=>managed.runtime().then(HttpApp.toWebHandlerRuntime));
    const app = (...args)=>Effect.map(Effect.promise(()=>managed.runPromise(createRequestHandler(opts, beAdapter))), Effect.provideServiceEffect(MiddlewareArguments, makeMiddlewareArgs(...args)));
    return async (...args)=>await handle.pipe(Effect.ap(app(...args)), Effect.ap(toRequest(...args)), Effect.withLogSpan("requestHandler"), managed.runPromise);
};
const createRequestHandler = (opts, beAdapter)=>Effect.gen(function*() {
        const isDevelopment = yield* IsDevelopment;
        const routerConfig = yield* extractRouterConfig$1(opts.router);
        const handleDaemon = (()=>{
            if (opts.config?.handleDaemonPromise) {
                return opts.config.handleDaemonPromise;
            }
            return isDevelopment ? "void" : "await";
        })();
        if (isDevelopment && handleDaemon === "await") {
            return yield* new UploadThingError({
                code: "INVALID_SERVER_CONFIG",
                message: 'handleDaemonPromise: "await" is forbidden in development.'
            });
        }
        const GET = Effect.gen(function*() {
            return yield* HttpServerResponse.json(routerConfig);
        });
        const POST = Effect.gen(function*() {
            const { "uploadthing-hook": uploadthingHook, "x-uploadthing-package": fePackage, "x-uploadthing-version": clientVersion } = yield* HttpServerRequest.schemaHeaders(S.Struct({
                "uploadthing-hook": UploadThingHook.pipe(S.optional),
                "x-uploadthing-package": S.String.pipe(S.optionalWith({
                    default: ()=>"unknown"
                })),
                "x-uploadthing-version": S.String.pipe(S.optionalWith({
                    default: ()=>version
                }))
            }));
            if (clientVersion !== version) {
                const msg = `Server version: ${version}, Client version: ${clientVersion}`;
                yield* Effect.logError(msg);
                return yield* new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Client version mismatch",
                    cause: msg
                });
            }
            const { slug, actionType } = yield* HttpRouter.schemaParams(S.Struct({
                actionType: ActionType.pipe(S.optional),
                slug: S.String
            }));
            const uploadable = opts.router[slug];
            if (!uploadable) {
                const msg = `No file route found for slug ${slug}`;
                yield* Effect.logError(msg);
                return yield* new UploadThingError({
                    code: "NOT_FOUND",
                    message: msg
                });
            }
            const { body, fiber } = yield* Match.value({
                actionType,
                uploadthingHook
            }).pipe(Match.when({
                actionType: "upload",
                uploadthingHook: undefined
            }, ()=>handleUploadAction({
                    uploadable,
                    fePackage,
                    beAdapter,
                    slug
                })), Match.when({
                actionType: undefined,
                uploadthingHook: "callback"
            }, ()=>handleCallbackRequest({
                    uploadable,
                    fePackage,
                    beAdapter
                })), Match.when({
                actionType: undefined,
                uploadthingHook: "error"
            }, ()=>handleErrorRequest({
                    uploadable
                })), Match.orElse(()=>Effect.succeed({
                    body: null,
                    fiber: null
                })));
            if (fiber) {
                yield* Effect.logDebug("Running fiber as daemon").pipe(Effect.annotateLogs("handleDaemon", handleDaemon));
                if (handleDaemon === "void") ; else if (handleDaemon === "await") {
                    yield* fiber.await;
                } else if (typeof handleDaemon === "function") {
                    handleDaemon(Effect.runPromise(fiber.await));
                }
            }
            yield* Effect.logDebug("Sending response").pipe(Effect.annotateLogs("body", body));
            return yield* HttpServerResponse.json(body);
        }).pipe(Effect.catchTags({
            ParseError: (e)=>HttpServerResponse.json(formatError(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid input",
                    cause: e.message
                }), opts.router), {
                    status: 400
                }),
            UploadThingError: (e)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                HttpServerResponse.json(formatError(e, opts.router), {
                    status: getStatusCodeFromError(e)
                })
        }));
        const appendResponseHeaders = Effect.map(HttpServerResponse.setHeader("x-uploadthing-version", version));
        return HttpRouter.empty.pipe(HttpRouter.get("*", GET), HttpRouter.post("*", POST), HttpRouter.use(appendResponseHeaders));
    }).pipe(Effect.withLogSpan("createRequestHandler"));
const handleErrorRequest = (opts)=>Effect.gen(function*() {
        const { uploadable } = opts;
        const request = yield* HttpServerRequest.HttpServerRequest;
        const { apiKey } = yield* UTToken;
        const verified = yield* verifySignature((yield* request.text), request.headers["x-uploadthing-signature"], apiKey);
        yield* Effect.logDebug(`Signature verified: ${verified}`);
        if (!verified) {
            yield* Effect.logError("Invalid signature");
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            });
        }
        const requestInput = yield* HttpServerRequest.schemaBodyJson(S.Struct({
            fileKey: S.String,
            error: S.String
        }));
        yield* Effect.logDebug("Handling error callback request with input:").pipe(Effect.annotateLogs("json", requestInput));
        const fiber = yield* Effect.tryPromise({
            try: async ()=>uploadable._def.onUploadError({
                    error: new UploadThingError({
                        code: "UPLOAD_FAILED",
                        message: `Upload failed for ${requestInput.fileKey}: ${requestInput.error}`
                    }),
                    fileKey: requestInput.fileKey
                }),
            catch: (error)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run onUploadError",
                    cause: error
                })
        }).pipe(Effect.tapError((error)=>Effect.logError("Failed to run onUploadError. You probably shouldn't be throwing errors here.").pipe(Effect.annotateLogs("error", error)))).pipe(Effect.ignoreLogged, Effect.forkDaemon);
        return {
            body: null,
            fiber
        };
    }).pipe(Effect.withLogSpan("handleErrorRequest"));
const handleCallbackRequest = (opts)=>Effect.gen(function*() {
        const { uploadable, fePackage, beAdapter } = opts;
        const request = yield* HttpServerRequest.HttpServerRequest;
        const { apiKey } = yield* UTToken;
        const verified = yield* verifySignature((yield* request.text), request.headers["x-uploadthing-signature"], apiKey);
        yield* Effect.logDebug(`Signature verified: ${verified}`);
        if (!verified) {
            yield* Effect.logError("Invalid signature");
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            });
        }
        const requestInput = yield* HttpServerRequest.schemaBodyJson(S.Struct({
            status: S.String,
            file: UploadedFileData,
            metadata: S.Record({
                key: S.String,
                value: S.Unknown
            })
        }));
        yield* Effect.logDebug("Handling callback request with input:").pipe(Effect.annotateLogs("json", requestInput));
        /**
     * Run `.onUploadComplete` as a daemon to prevent the
     * request from UT to potentially timeout.
     */ const fiber = yield* Effect.gen(function*() {
            const serverData = yield* Effect.tryPromise({
                try: async ()=>uploadable.resolver({
                        file: requestInput.file,
                        metadata: requestInput.metadata
                    }),
                catch: (error)=>new UploadThingError({
                        code: "INTERNAL_SERVER_ERROR",
                        message: "Failed to run onUploadComplete. You probably shouldn't be throwing errors here.",
                        cause: error
                    })
            });
            const payload = {
                fileKey: requestInput.file.key,
                callbackData: serverData ?? null
            };
            yield* Effect.logDebug("'onUploadComplete' callback finished. Sending response to UploadThing:").pipe(Effect.annotateLogs("callbackData", payload));
            const baseUrl = yield* IngestUrl;
            const httpClient = yield* HttpClient.HttpClient;
            yield* HttpClientRequest.post(`/callback-result`).pipe(HttpClientRequest.prependUrl(baseUrl), HttpClientRequest.setHeaders({
                "x-uploadthing-api-key": apiKey,
                "x-uploadthing-version": version,
                "x-uploadthing-be-adapter": beAdapter,
                "x-uploadthing-fe-package": fePackage
            }), HttpClientRequest.jsonBody(payload), Effect.flatMap(HttpClient.filterStatusOk(httpClient)), Effect.tapErrorTag("ResponseError", ({ response: res })=>Effect.flatMap(res.json, (json)=>Effect.logError(`Failed to register callback result (${res.status})`).pipe(Effect.annotateLogs("error", json)))), HttpClientResponse.schemaBodyJsonScoped(CallbackResultResponse), Effect.tap(Effect.log("Sent callback result to UploadThing")));
        }).pipe(Effect.ignoreLogged, Effect.forkDaemon);
        return {
            body: null,
            fiber
        };
    }).pipe(Effect.withLogSpan("handleCallbackRequest"));
const runRouteMiddleware = (opts)=>Effect.gen(function*() {
        const middlewareArgs = yield* MiddlewareArguments;
        const { json: { files, input }, uploadable } = opts;
        yield* Effect.logDebug("Running middleware");
        const metadata = yield* Effect.tryPromise({
            try: async ()=>uploadable._def.middleware({
                    ...middlewareArgs,
                    input,
                    files
                }),
            catch: (error)=>error instanceof UploadThingError ? error : new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run middleware",
                    cause: error
                })
        });
        if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
            const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
            });
        }
        // Attach customIds from middleware to the files
        const filesWithCustomIds = yield* Effect.forEach(files, (file, idx)=>Effect.gen(function*() {
                const theirs = metadata[UTFiles]?.[idx];
                if (theirs && theirs.size !== file.size) {
                    yield* Effect.logWarning("File size mismatch. Reverting to original size");
                }
                return {
                    name: theirs?.name ?? file.name,
                    size: file.size,
                    type: file.type,
                    customId: theirs?.customId,
                    lastModified: theirs?.lastModified ?? Date.now()
                };
            }));
        return {
            metadata,
            filesWithCustomIds
        };
    }).pipe(Effect.withLogSpan("runRouteMiddleware"));
const handleUploadAction = (opts)=>Effect.gen(function*() {
        const httpClient = yield* HttpClient.HttpClient;
        const { uploadable, fePackage, beAdapter, slug } = opts;
        const json = yield* HttpServerRequest.schemaBodyJson(UploadActionPayload);
        yield* Effect.logDebug("Handling upload request").pipe(Effect.annotateLogs("json", json));
        // validate the input
        yield* Effect.logDebug("Parsing user input");
        const inputParser = uploadable._def.inputParser;
        const parsedInput = yield* Effect.tryPromise({
            try: async ()=>getParseFn(inputParser)(json.input),
            catch: (error)=>new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid input",
                    cause: error
                })
        });
        yield* Effect.logDebug("Input parsed successfully").pipe(Effect.annotateLogs("input", parsedInput));
        const { metadata, filesWithCustomIds } = yield* runRouteMiddleware({
            json: {
                input: parsedInput,
                files: json.files
            },
            uploadable
        });
        yield* Effect.logDebug("Parsing route config").pipe(Effect.annotateLogs("routerConfig", uploadable._def.routerConfig));
        const parsedConfig = yield* fillInputRouteConfig(uploadable._def.routerConfig).pipe(Effect.catchTag("InvalidRouteConfig", (err)=>new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid route config",
                cause: err
            })));
        yield* Effect.logDebug("Route config parsed successfully").pipe(Effect.annotateLogs("routeConfig", parsedConfig));
        yield* Effect.logDebug("Validating files meet the config requirements").pipe(Effect.annotateLogs("files", json.files));
        yield* assertFilesMeetConfig(json.files, parsedConfig).pipe(Effect.mapError((e)=>new UploadThingError({
                code: "BAD_REQUEST",
                message: `Invalid config: ${e._tag}`,
                cause: "reason" in e ? e.reason : e.message
            })));
        yield* Effect.logDebug("Files validated.");
        const fileUploadRequests = yield* Effect.forEach(filesWithCustomIds, (file)=>Effect.map(getTypeFromFileName(file.name, objectKeys(parsedConfig)), (type)=>({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified,
                    customId: file.customId,
                    contentDisposition: parsedConfig[type]?.contentDisposition ?? "inline",
                    acl: parsedConfig[type]?.acl
                }))).pipe(Effect.catchTags({
            /** Shouldn't happen since config is validated above so just dying is fine I think */ InvalidFileType: (e)=>Effect.die(e),
            UnknownFileType: (e)=>Effect.die(e)
        }));
        const routeOptions = uploadable._def.routeOptions;
        const { apiKey, appId } = yield* UTToken;
        const ingestUrl = yield* IngestUrl;
        const isDev = yield* IsDevelopment;
        yield* Effect.logDebug("Generating presigned URLs").pipe(Effect.annotateLogs("fileUploadRequests", fileUploadRequests), Effect.annotateLogs("ingestUrl", ingestUrl));
        const presignedUrls = yield* Effect.forEach(fileUploadRequests, (file)=>Effect.gen(function*() {
                const key = yield* generateKey(file, appId, routeOptions.getFileHashParts);
                const url = yield* generateSignedURL(`${ingestUrl}/${key}`, apiKey, {
                    ttlInSeconds: routeOptions.presignedURLTTL,
                    data: {
                        "x-ut-identifier": appId,
                        "x-ut-file-name": file.name,
                        "x-ut-file-size": file.size,
                        "x-ut-file-type": file.type,
                        "x-ut-slug": slug,
                        "x-ut-custom-id": file.customId,
                        "x-ut-content-disposition": file.contentDisposition,
                        "x-ut-acl": file.acl
                    }
                });
                return {
                    url,
                    key
                };
            }), {
            concurrency: "unbounded"
        });
        const serverReq = yield* HttpServerRequest.HttpServerRequest;
        const requestUrl = yield* HttpServerRequest.toURL(serverReq);
        const devHookRequest = yield* Config.string("callbackUrl").pipe(Config.withDefault(requestUrl.origin + requestUrl.pathname), Effect.map((url)=>HttpClientRequest.post(url).pipe(HttpClientRequest.appendUrlParam("slug", slug))));
        const metadataRequest = HttpClientRequest.post("/route-metadata").pipe(HttpClientRequest.prependUrl(ingestUrl), HttpClientRequest.setHeaders({
            "x-uploadthing-api-key": apiKey,
            "x-uploadthing-version": version,
            "x-uploadthing-be-adapter": beAdapter,
            "x-uploadthing-fe-package": fePackage
        }), HttpClientRequest.jsonBody({
            fileKeys: presignedUrls.map(({ key })=>key),
            metadata: metadata,
            isDev,
            callbackUrl: devHookRequest.url,
            callbackSlug: slug,
            awaitServerData: routeOptions.awaitServerData ?? true
        }), Effect.flatMap(HttpClient.filterStatusOk(httpClient)), Effect.tapBoth({
            onSuccess: (res)=>Effect.logDebug("Registerred metadata").pipe(Effect.annotateLogs("response", res)),
            onFailure: (err)=>err._tag === "ResponseError" ? Effect.flatMap(err.response.json, (json)=>Effect.logError(`Failed to register metadata (${err.response.status})`).pipe(Effect.annotateLogs("response", err.response), Effect.annotateLogs("json", json))) : Effect.logError("Failed to register metadata").pipe(Effect.annotateLogs("error", err))
        }));
        // Send metadata to UT server (non blocking as a daemon)
        // In dev, keep the stream open and simulate the callback requests as
        // files complete uploading
        const fiber = yield* Effect.if(isDev, {
            onTrue: ()=>metadataRequest.pipe(HttpClientResponse.stream, handleJsonLineStream(MetadataFetchStreamPart, ({ payload, signature, hook })=>devHookRequest.pipe(HttpClientRequest.setHeaders({
                        "uploadthing-hook": hook,
                        "x-uploadthing-signature": signature
                    }), HttpClientRequest.setBody(HttpBody.text(payload, "application/json")), httpClient, HttpClientResponse.arrayBuffer, Effect.asVoid, Effect.tap(Effect.log(`Successfully simulated '${hook}' event`)), Effect.ignoreLogged))),
            onFalse: ()=>metadataRequest.pipe(HttpClientResponse.schemaBodyJsonScoped(MetadataFetchResponse))
        }).pipe(Effect.forkDaemon);
        const presigneds = presignedUrls.map((p, i)=>({
                url: p.url,
                key: p.key,
                name: fileUploadRequests[i].name,
                customId: fileUploadRequests[i].customId ?? null
            }));
        yield* Effect.logInfo("Sending presigned URLs to client").pipe(Effect.annotateLogs("presignedUrls", presigneds));
        return {
            body: presigneds,
            fiber
        };
    }).pipe(Effect.withLogSpan("handleUploadAction"));

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        routeOptions: {
            awaitServerData: true
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>{
        // noop
        },
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input, config)=>{
        return internalCreateBuilder({
            routerConfig: input,
            routeOptions: config ?? {},
            ...opts
        });
    };
}

/**
 * Extension of the Blob class that simplifies setting the `name` and `customId` properties,
 * similar to the built-in File class from Node > 20.
 */ class UTFile extends Blob {
    constructor(parts, name, options){
        const optionsWithDefaults = {
            ...options,
            type: options?.type ?? (lookup(name) || "application/octet-stream"),
            lastModified: options?.lastModified ?? Date.now()
        };
        super(parts, optionsWithDefaults);
        this.name = name;
        this.customId = optionsWithDefaults.customId;
        this.lastModified = optionsWithDefaults.lastModified;
    }
}

const uploadWithoutProgress = (file, presigned)=>Effect.gen(function*() {
        const formData = new FormData();
        formData.append("file", file); // File data **MUST GO LAST**
        const httpClient = yield* HttpClient.HttpClient;
        const json = yield* HttpClientRequest.put(presigned.url).pipe(HttpClientRequest.formDataBody(formData), HttpClientRequest.setHeader("Range", "bytes=0-"), HttpClient.filterStatusOk(httpClient), Effect.mapError((e)=>new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "Failed to upload file",
                cause: e
            })), HttpClientResponse.json, Effect.andThen(unsafeCoerce));
        yield* Effect.logDebug(`File ${file.name} uploaded successfully`).pipe(Effect.annotateLogs("json", json));
        return json;
    });

function guardServerOnly() {
    if (typeof window !== "undefined") {
        throw new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "The `utapi` can only be used on the server."
        });
    }
}
const uploadFilesInternal = (input)=>getPresignedUrls(input).pipe(Effect.andThen((presigneds)=>Effect.forEach(presigneds, (file)=>uploadFile(file).pipe(Effect.tapError((error)=>Effect.logError("Upload failed").pipe(Effect.annotateLogs("error", error))), Effect.match({
                onFailure: (error)=>({
                        data: null,
                        error: UploadThingError.toObject(error instanceof UploadThingError ? error : new UploadThingError({
                            message: "Failed to upload file.",
                            code: "BAD_REQUEST",
                            cause: error
                        }))
                    }),
                onSuccess: (data)=>({
                        data,
                        error: null
                    })
            })), {
            concurrency: 10
        })));
/**
 * FIXME: downloading everything into memory and then upload
 * isn't the best. We should support streams so we can download
 * just as much as we need at any time.
 */ const downloadFiles = (urls, downloadErrors)=>Effect.forEach(urls, (_url, idx)=>Effect.gen(function*() {
            let url = isObject(_url) ? _url.url : _url;
            if (typeof url === "string") {
                // since dataurls will result in name being too long, tell the user
                // to use uploadFiles instead.
                if (url.startsWith("data:")) {
                    downloadErrors[idx] = UploadThingError.toObject(new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only."
                    }));
                    return null;
                }
            }
            url = new URL(url);
            const { name = url.pathname.split("/").pop() ?? "unknown-filename", customId = undefined } = isObject(_url) ? _url : {};
            const arrayBuffer = yield* HttpClientRequest.get(url).pipe(HttpClientRequest.modify({
                headers: {}
            }), HttpClient.filterStatusOk((yield* HttpClient.HttpClient)), HttpClientResponse.arrayBuffer, Effect.mapError((error)=>{
                downloadErrors[idx] = UploadThingError.toObject(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Failed to download requested file.",
                    cause: error
                }));
                return Effect.succeed(undefined);
            }));
            return new UTFile([
                arrayBuffer
            ], name, {
                customId,
                lastModified: Date.now()
            });
        }).pipe(Effect.withLogSpan("downloadFile")), {
        concurrency: 10
    });
const getPresignedUrls = (input)=>Effect.gen(function*() {
        const { files, contentDisposition, acl } = input;
        yield* Effect.logDebug("Generating presigned URLs for files").pipe(Effect.annotateLogs("files", files));
        const { apiKey, appId } = yield* UTToken;
        const baseUrl = yield* IngestUrl;
        const presigneds = yield* Effect.forEach(files, (file)=>Effect.gen(function*() {
                const key = yield* generateKey(file, appId);
                const url = yield* generateSignedURL(`${baseUrl}/${key}`, apiKey, {
                    // ttlInSeconds: routeOptions.presignedURLTTL,
                    data: {
                        "x-ut-identifier": appId,
                        "x-ut-file-name": file.name,
                        "x-ut-file-size": file.size,
                        "x-ut-file-type": file.type,
                        "x-ut-custom-id": file.customId,
                        "x-ut-content-disposition": contentDisposition,
                        "x-ut-acl": acl
                    }
                });
                return {
                    url,
                    key
                };
            }));
        yield* Effect.logDebug("Generated presigned URLs").pipe(Effect.annotateLogs("presigneds", presigneds));
        return files.map((file, i)=>({
                file,
                presigned: presigneds[i]
            }));
    }).pipe(Effect.withLogSpan("getPresignedUrls"));
const uploadFile = (input)=>Effect.gen(function*() {
        const { file, presigned } = input;
        const { url, appUrl } = yield* uploadWithoutProgress(file, presigned);
        return {
            key: presigned.key,
            url: url,
            appUrl: appUrl,
            lastModified: file.lastModified ?? Date.now(),
            name: file.name,
            size: file.size,
            type: file.type,
            customId: file.customId ?? null
        };
    }).pipe(Effect.withLogSpan("uploadFile"));

class UTApi {
    constructor(opts){
        this.opts = opts;
        this.requestUploadThing = (pathname, body, responseSchema)=>Effect.gen(this, function*() {
                const { apiKey } = yield* UTToken;
                const baseUrl = yield* ApiUrl;
                const httpClient = yield* HttpClient.HttpClient;
                return yield* HttpClientRequest.post(pathname).pipe(HttpClientRequest.prependUrl(baseUrl), HttpClientRequest.unsafeJsonBody(body), HttpClientRequest.setHeaders({
                    "x-uploadthing-version": version,
                    "x-uploadthing-be-adapter": "server-sdk",
                    "x-uploadthing-api-key": apiKey
                }), HttpClient.filterStatusOk(httpClient), Effect.tapBoth({
                    onSuccess: (res)=>Effect.logDebug(`UT Response`).pipe(Effect.annotateLogs("res", res)),
                    onFailure: (err)=>Effect.logError("UploadThing error").pipe(Effect.annotateLogs("error", err))
                }), HttpClientResponse.schemaBodyJsonScoped(responseSchema));
            }).pipe(Effect.withLogSpan("utapi.#requestUploadThing"));
        this.executeAsync = (program, signal)=>{
            return program.pipe(Effect.provide(PrettyLogger.layer({
                showFiberId: false
            })), Effect.provide(withMinimalLogLevel), Effect.provide(HttpClient.layer), Effect.provide(Layer.effect(HttpClient.Fetch, Effect.succeed(this.fetch))), Effect.provide(Layer.setConfigProvider(configProvider(this.opts))), Effect.withLogSpan("utapi.#executeAsync"), (e)=>Effect.runPromise(e, signal ? {
                    signal
                } : undefined));
        };
        this./**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   *
   * @example
   * await deleteFiles("myCustomIdentifier", { keyType: "customId" })
   */ deleteFiles = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class DeleteFileResponse extends S.Class("DeleteFileResponse")({
                success: S.Boolean,
                deletedCount: S.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/deleteFiles", keyType === "fileKey" ? {
                fileKeys: asArray(keys)
            } : {
                customIds: asArray(keys)
            }, DeleteFileResponse).pipe(Effect.withLogSpan("deleteFiles")));
        };
        this./**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */ getFileUrls = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class GetFileUrlResponse extends S.Class("GetFileUrlResponse")({
                data: S.Array(S.Struct({
                    key: S.String,
                    url: S.String
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getFileUrl", keyType === "fileKey" ? {
                fileKeys: keys
            } : {
                customIds: keys
            }, GetFileUrlResponse).pipe(Effect.withLogSpan("getFileUrls")));
        };
        this./**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */ listFiles = async (opts)=>{
            guardServerOnly();
            class ListFileResponse extends S.Class("ListFileResponse")({
                hasMore: S.Boolean,
                files: S.Array(S.Struct({
                    id: S.String,
                    customId: S.NullOr(S.String),
                    key: S.String,
                    name: S.String,
                    status: S.Literal("Deletion Pending", "Failed", "Uploaded", "Uploading")
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/listFiles", {
                ...opts
            }, ListFileResponse).pipe(Effect.withLogSpan("listFiles")));
        };
        this.renameFiles = async (updates)=>{
            guardServerOnly();
            class RenameFileResponse extends S.Class("RenameFileResponse")({
                success: S.Boolean
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/renameFiles", {
                updates: asArray(updates)
            }, RenameFileResponse).pipe(Effect.withLogSpan("renameFiles")));
        };
        this.getUsageInfo = async ()=>{
            guardServerOnly();
            class GetUsageInfoResponse extends S.Class("GetUsageInfoResponse")({
                totalBytes: S.Number,
                appTotalBytes: S.Number,
                filesUploaded: S.Number,
                limitBytes: S.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getUsageInfo", {}, GetUsageInfoResponse).pipe(Effect.withLogSpan("getUsageInfo")));
        };
        this./** Request a presigned url for a private file(s) */ getSignedURL = async (key, opts)=>{
            guardServerOnly();
            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;
            const { keyType = this.defaultKeyType } = opts ?? {};
            if (opts?.expiresIn && isNaN(expiresIn)) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
                });
            }
            if (expiresIn && expiresIn > 86400 * 7) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be less than 7 days (604800 seconds)."
                });
            }
            class GetSignedUrlResponse extends S.Class("GetSignedUrlResponse")({
                url: S.String
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/requestFileAccess", keyType === "fileKey" ? {
                fileKey: key,
                expiresIn
            } : {
                customId: key,
                expiresIn
            }, GetSignedUrlResponse).pipe(Effect.withLogSpan("getSignedURL")));
        };
        this./**
   * Update the ACL of a file or set of files.
   *
   * @example
   * // Make a single file public
   * await utapi.updateACL("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", "public-read");
   *
   * // Make multiple files private
   * await utapi.updateACL(
   *   [
   *     "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *     "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg",
   *   ],
   *   "private",
   * );
   */ updateACL = async (keys, acl, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            const updates = asArray(keys).map((key)=>{
                return keyType === "fileKey" ? {
                    fileKey: key,
                    acl
                } : {
                    customId: key,
                    acl
                };
            });
            const responseSchema = S.Struct({
                success: S.Boolean
            });
            return await this.executeAsync(this.requestUploadThing("/v6/updateACL", {
                updates
            }, responseSchema).pipe(Effect.withLogSpan("updateACL")));
        };
        // Assert some stuff
        guardServerOnly();
        this.fetch = opts?.fetch ?? globalThis.fetch;
        this.defaultKeyType = opts?.defaultKeyType ?? "fileKey";
    }
    async uploadFiles(files, opts) {
        guardServerOnly();
        const uploads = await this.executeAsync(Effect.flatMap(uploadFilesInternal({
            files: asArray(files),
            contentDisposition: opts?.contentDisposition ?? "inline",
            acl: opts?.acl
        }), (ups)=>Effect.succeed(Array.isArray(files) ? ups : ups[0])).pipe(Effect.tap((res)=>Effect.logDebug("Finished uploading").pipe(Effect.annotateLogs("uploadResult", res))), Effect.withLogSpan("uploadFiles")), opts?.signal);
        return uploads;
    }
    async uploadFilesFromUrl(urls, opts) {
        guardServerOnly();
        const downloadErrors = {};
        const arr = asArray(urls);
        const program = Effect.gen(function*() {
            const downloadedFiles = yield* downloadFiles(arr, downloadErrors).pipe(Effect.map((files)=>Arr.filter(files, Predicate.isNotNullable)));
            yield* Effect.logDebug(`Downloaded ${downloadedFiles.length}/${arr.length} files`).pipe(Effect.annotateLogs("downloadedFiles", downloadedFiles));
            const uploads = yield* uploadFilesInternal({
                files: downloadedFiles,
                contentDisposition: opts?.contentDisposition ?? "inline",
                acl: opts?.acl
            });
            /** Put it all back together, preserve the order of files */ const responses = arr.map((_, index)=>{
                if (downloadErrors[index]) {
                    return {
                        data: null,
                        error: downloadErrors[index]
                    };
                }
                return uploads.shift();
            });
            /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];
            yield* Effect.logDebug("Finished uploading").pipe(Effect.annotateLogs("uploadResult", uploadFileResponse), Effect.withLogSpan("utapi.uploadFilesFromUrl"));
            return uploadFileResponse;
        }).pipe(Effect.withLogSpan("uploadFilesFromUrl"));
        return await this.executeAsync(program, opts?.signal);
    }
}

const createUploadthing = (opts)=>createBuilder(opts);
const createRouteHandler = (opts)=>{
    return makeAdapterHandler((req)=>Effect.succeed({
            req,
            res: undefined,
            event: undefined
        }), (ev)=>Effect.succeed("request" in ev ? ev.request : ev), opts, "server");
};
const extractRouterConfig = (router)=>Effect.runSync(extractRouterConfig$1(router));

export { UTApi, UTFile, createRouteHandler, createUploadthing, extractRouterConfig };
